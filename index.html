<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>STEP Viewer Demo - PROFILE EQUIPMENT BV</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --bg-alt: #0b1220;
      --card-bg: #020617;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --border: #1f2937;
      --danger: #ef4444;
      --success: #22c55e;
      --radius-lg: 18px;
      --radius-xl: 24px;
      --shadow-soft: 0 20px 40px rgba(15, 23, 42, 0.9);
      --transition: 180ms ease;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app-shell {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 1200px;
      margin: 16px;
      border-radius: 24px;
      background: linear-gradient(145deg, #020617 0, #020617 40%, #020617 100%);
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.9);
      overflow: hidden;
    }

    header {
      padding: 16px 24px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      display: flex;
      align-items: center;
      gap: 12px;
      background: radial-gradient(circle at top left, #0f172a 0, #020617 55%);
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: #e0f2fe;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border: 1px solid rgba(56, 189, 248, 0.6);
    }

    h1 {
      font-size: 18px;
      margin: 0;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1 span.icon {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 30% 0, #38bdf8 0, #0f172a 60%);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.9);
      font-size: 14px;
    }

    header p {
      margin: 2px 0 0;
      font-size: 13px;
      color: var(--text-soft);
    }

    main {
      display: flex;
      flex: 1;
      min-height: 480px;
    }

    .wizard-pane {
      width: 360px;
      max-width: 100%;
      border-right: 1px solid rgba(148, 163, 184, 0.18);
      padding: 18px 18px 22px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: radial-gradient(circle at top left, var(--bg) 0, var(--bg-alt) 60%);
    }

    .viewer-pane {
      flex: 1;
      position: relative;
      background: radial-gradient(circle at top, #020617 0, #000 70%);
      display: flex;
      flex-direction: column;
    }

    .card {
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: radial-gradient(circle at top left, #020617 0, #020617 70%);
      padding: 14px 14px 12px;
      box-shadow: 0 16px 30px rgba(15, 23, 42, 0.7);
    }

    .card h2 {
      font-size: 15px;
      margin: 0 0 4px;
      font-weight: 600;
    }

    .card p {
      margin: 0 0 10px;
      font-size: 13px;
      color: var(--text-soft);
    }

    .field-label {
      font-size: 12px;
      margin-bottom: 4px;
      color: var(--text-soft);
    }

    .file-input {
      width: 100%;
      padding: 9px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-soft);
      font-size: 12px;
    }

    .file-input:hover { border-style: solid; }

    .btn-row {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      padding: 7px 12px;
      font-size: 12px;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 180ms ease, box-shadow 180ms ease,
        background 180ms ease, border-color 180ms ease;
    }

    button span.dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.8);
    }

    button.primary {
      background: linear-gradient(135deg, #22c55e, #38bdf8);
      border-color: transparent;
      color: #0b1120;
      font-weight: 500;
      box-shadow: 0 10px 18px rgba(56, 189, 248, 0.35);
    }

    button.primary span.dot { background: #0b1120; }

    button.ghost { background: rgba(15, 23, 42, 0.9); }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 14px rgba(15, 23, 42, 0.9);
    }

    button.primary:hover {
      box-shadow: 0 12px 22px rgba(56, 189, 248, 0.55);
    }

    .mini-note {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
    }

    .badge-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.55);
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.85);
    }

    .badge.good {
      border-color: rgba(34, 197, 94, 0.8);
      color: #bbf7d0;
      background: rgba(22, 101, 52, 0.25);
    }

    .badge.warn {
      border-color: rgba(248, 250, 252, 0.4);
      color: #e5e7eb;
      background: rgba(30, 64, 175, 0.3);
    }

    .badge.error {
      border-color: rgba(248, 113, 113, 0.9);
      color: #fecaca;
      background: rgba(127, 29, 29, 0.4);
    }

    .hidden { display: none !important; }

    .viewer-header {
      padding: 10px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.25);
      font-size: 12px;
      color: var(--text-soft);
    }

    .viewer-header strong {
      color: var(--text);
      font-weight: 500;
    }

    .viewer-canvas-wrap {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #viewer-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .viewer-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      font-size: 13px;
      color: var(--text-soft);
      text-align: center;
      padding: 0 16px;
      pointer-events: none;
    }

    .dot-pulse {
      display: inline-flex;
      gap: 5px;
      align-items: center;
      justify-content: center;
    }

    .dot-pulse span {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
      animation: pulse 1s infinite ease-in-out;
    }

    .dot-pulse span:nth-child(2) { animation-delay: 0.12s; }
    .dot-pulse span:nth-child(3) { animation-delay: 0.24s; }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.4; }
      50% { transform: scale(1.4); opacity: 1; }
    }

    @media (max-width: 880px) {
      .app-shell { flex-direction: column; }
      main { flex-direction: column; }
      .wizard-pane {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      }
    }
  </style>

  <!-- OCCT (WebAssembly loader) -->
  <script src="occt-import-js.js"></script>

  <!-- Three.js klassiek + OrbitControls (r110: OrbitControls als globale constructor) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
<div class="app-shell">
  <header>
    <div style="flex:1">
      <h1><span class="icon">3D</span> STEP viewer</h1>
      <p>Upload een STEP-bestand en bekijk het model direct in de browser.</p>
    </div>
  </header>

  <main>
    <!-- Linkerzijde: controls -->
    <aside class="wizard-pane">
      <section class="card">
        <h2>STEP-bestand uploaden</h2>
        <p>Kies een <strong>.step</strong> of <strong>.stp</strong>-bestand om te bekijken.</p>

        <label class="field-label" for="stepFileInput">STEP / STP bestand</label>
        <input id="stepFileInput" class="file-input" type="file" accept=".step,.stp" />

        <div class="btn-row">
          <button type="button" id="btnLoadDemo" class="ghost">
            <span class="dot"></span> Voorbeeldbestand
          </button>
          <button type="button" id="btnRefresh" class="ghost">
            <span class="dot"></span> Nieuwe sessie
          </button>
          <button type="button" id="btnMeasureToggle" class="primary">
            <span class="dot"></span> Meten: uit
          </button>
        </div>

        <div class="mini-note">
          Bestanden blijven in de browser; er wordt niets naar een server ge√ºpload.
        </div>
      </section>

      <div class="badge-list">
        <div class="badge warn">Alle logica draait volledig client-side, wij slaan niets op!</div>
        <div class="badge good">PROFILE EQUIPMENT BV</div>
      </div>
    </aside>

    <!-- Viewer -->
    <section class="viewer-pane">
      <div class="viewer-header">
        <div>
          <strong id="viewerTitle">Geen model geladen</strong><br />
          <span id="viewerMeta">Upload een bestand of gebruik het demo-bestand.</span>
        </div>
        <div class="dot-pulse" id="viewerStatusDots" style="opacity:0.1;">
          <span></span><span></span><span></span>
        </div>
      </div>
      <div class="viewer-canvas-wrap">
        <canvas id="viewer-canvas"></canvas>
        <div class="viewer-placeholder" id="viewerPlaceholder">
          <div class="badge warn">Viewer inactief</div>
          <div>
            Upload een STEP-bestand links<br />
            of klik op <em>Voorbeeldbestand</em>.
          </div>
        </div>
      </div>
    </section>
  </main>
</div>

<script>
  // ---- State ----
  const state = {
    stepFile: null,
    stepFileName: null,
    occtLoaded: false,
    occtFailed: false,
    occtPromise: null,
    gridHelper: null,
    three: {
      scene: null,
      camera: null,
      renderer: null,
      controls: null,
      canvas: null
    },
    // Meet-functie
    measure: {
      enabled: false,
      points: [],
      line: null,
      labelEl: null,
      raycaster: new THREE.Raycaster(),
      mouse: new THREE.Vector2()
    }
  };

  const $ = (id) => document.getElementById(id);

  async function ensureOcct() {
    if (state.occtFailed) return null;
    if (state.occtPromise) return state.occtPromise;

    if (typeof window.occtimportjs !== "function") {
      state.occtFailed = true;
      console.warn("occt-import-js.js niet gevonden of niet geladen.");
      return null;
    }

    state.occtPromise = window.occtimportjs()
      .then(occt => {
        state.occtLoaded = true;
        console.log("‚úÖ OCCT succesvol geladen");
        return occt;
      })
      .catch(err => {
        console.warn("Kon occt-import-js niet initialiseren:", err);
        state.occtFailed = true;
        return null;
      });

    return state.occtPromise;
  }

  function initViewer() {
    const canvas = $("viewer-canvas");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 50000);
    camera.position.set(200,200,200);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x111827, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(200,200,100);
    scene.add(dir);

    state.gridHelper = null;
    state.three = { scene, camera, renderer, controls, canvas };

    function onResize() {
      const rect = canvas.getBoundingClientRect();
      const width = rect.width || canvas.clientWidth || 100;
      const height = rect.height || canvas.clientHeight || 100;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height, false);
    }
    window.addEventListener("resize", onResize);
    onResize();

    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();

    // Klikken op canvas gebruiken voor afstand meten
    canvas.addEventListener("click", onCanvasClickForMeasure);

    console.log("‚úÖ Three.js viewer ge√Ønitialiseerd");
  }

  function clearSceneMeshes() {
    const scene = state.three.scene;
    if (!scene) return;
    const toRemove = [];
    scene.traverse(obj => {
      if (obj.isMesh || obj.type === 'GridHelper') toRemove.push(obj);
    });
    toRemove.forEach(m => scene.remove(m));
    if (state.gridHelper) {
      scene.remove(state.gridHelper);
      state.gridHelper = null;
    }
    console.log("üßπ Scene meshes verwijderd");
  }

  function colorArrayToHex(colorArray) {
    if (!colorArray || colorArray.length < 3) return 0x4b5563;
    const [r,g,b] = colorArray;
    const rr = Math.round(r*255);
    const gg = Math.round(g*255);
    const bb = Math.round(b*255);
    return (rr << 16) | (gg << 8) | bb;
  }

  function focusCameraOnScene() {
    const { scene, camera, controls } = state.three;

    const box = new THREE.Box3();
    let hasMeshes = false;
    scene.traverse(obj => {
      if (obj.isMesh) {
        box.expandByObject(obj);
        hasMeshes = true;
      }
    });

    if (!hasMeshes || !isFinite(box.min.x) || !isFinite(box.max.x)) {
      console.warn("‚ö†Ô∏è Geen geldige meshes gevonden voor camera focus");
      return;
    }

    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box.getSize(size);
    box.getCenter(center);

    console.log("üìè Model grootte:", size);
    console.log("üìç Model centrum:", center);

    const maxDim = Math.max(size.x, size.y, size.z);
    const gridSize = Math.max(maxDim * 2, 100);
    const gridDivisions = 20;

    if (state.gridHelper) {
      scene.remove(state.gridHelper);
    }
    state.gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x1f2933, 0x0f172a);
    state.gridHelper.position.y = box.min.y - 1;
    scene.add(state.gridHelper);

    const fov = camera.fov * Math.PI / 180;
    let dist = maxDim / (2 * Math.tan(fov/2));
    dist *= 2.5;

    const offset = new THREE.Vector3(dist, dist*0.7, dist);
    camera.position.copy(center).add(offset);
    camera.lookAt(center);

    controls.target.copy(center);
    controls.update();

    camera.near = maxDim * 0.01;
    camera.far = maxDim * 100;
    camera.updateProjectionMatrix();

    console.log("üìπ Camera positie:", camera.position);
    console.log("üéØ Camera kijkt naar:", controls.target);
  }

  // --- Helpers voor meten ---
  function ensureMeasureLabel() {
    if (state.measure.labelEl) return state.measure.labelEl;

    const el = document.createElement("div");
    el.style.position = "absolute";
    el.style.right = "12px";
    el.style.bottom = "12px";
    el.style.padding = "6px 10px";
    el.style.borderRadius = "999px";
    el.style.background = "rgba(15,23,42,0.9)";
    el.style.border = "1px solid rgba(148,163,184,0.6)";
    el.style.fontSize = "11px";
    el.style.color = "#e5e7eb";
    el.style.pointerEvents = "none";
    el.style.zIndex = "10";
    el.textContent = "Meten: kies twee punten";
    state.measure.labelEl = el;

    const wrap = document.querySelector(".viewer-canvas-wrap");
    wrap.appendChild(el);
    return el;
  }

  function clearMeasurement() {
    const { scene } = state.three;
    const { line, labelEl } = state.measure;

    state.measure.points = [];

    if (line && scene) {
      scene.remove(line);
    }
    state.measure.line = null;

    if (labelEl) {
      labelEl.remove();
      state.measure.labelEl = null;
    }
  }

  function onCanvasClickForMeasure(event) {
    if (!state.measure.enabled) return;
    if (!state.three.scene || !state.three.camera || !state.three.canvas) return;

    const { scene, camera, canvas } = state.three;
    const { raycaster, mouse, points } = state.measure;

    const rect = canvas.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const meshes = [];
    scene.traverse(obj => {
      if (obj.isMesh) meshes.push(obj);
    });

    const intersects = raycaster.intersectObjects(meshes, true);
    if (!intersects.length) return;

    const point = intersects[0].point.clone();
    points.push(point);

    if (points.length === 1) {
      const label = ensureMeasureLabel();
      label.textContent = "1e punt gekozen ‚Äì klik 2e punt";
      return;
    }

    if (points.length === 2) {
      const p1 = points[0];
      const p2 = points[1];

      const distance = p1.distanceTo(p2); // als STEP in mm, dan is dit mm
      const distanceMm = distance;

      const geometry = new THREE.BufferGeometry().setFromPoints([p1, p2]);
      const material = new THREE.LineBasicMaterial({ linewidth: 2 });
      const line = new THREE.Line(geometry, material);

      if (state.measure.line) {
        scene.remove(state.measure.line);
      }
      scene.add(line);
      state.measure.line = line;

      const label = ensureMeasureLabel();
      label.textContent = `Afstand: ${distanceMm.toFixed(2)} mm`;

      // klaar met deze meting, volgende meting weer twee punten
      state.measure.points = [];
    }
  }

  async function loadStepIntoViewer(file) {
    console.log("üöÄ Start laden STEP-bestand:", file.name);

    $("viewerTitle").textContent = state.stepFileName || "Model laden...";
    $("viewerMeta").textContent = "STEP-bestand wordt verwerkt met OpenCascade (occt-import-js)...";
    $("viewerStatusDots").style.opacity = "1";
    $("viewerPlaceholder").classList.add("hidden");

    if (!state.three.scene) {
      console.log("üé¨ Initialiseer Three.js viewer...");
      initViewer();
    }

    const occt = await ensureOcct();
    if (!occt) {
      $("viewerMeta").textContent = "occt-import-js is niet beschikbaar (check bestanden & hosting).";
      $("viewerPlaceholder").classList.remove("hidden");
      $("viewerPlaceholder").innerHTML =
        '<div class="badge error">OCCT niet geladen</div>' +
        '<div>Controleer of occt-import-js.js en occt-import-js.wasm naast deze HTML staan, ' +
        'en dat je via http(s) host (niet via file://).</div>';
      $("viewerStatusDots").style.opacity = "0.15";
      return;
    }

    try {
      console.log("üì¶ Lees bestand als ArrayBuffer...");
      const buffer = await file.arrayBuffer();
      const fileBuffer = new Uint8Array(buffer);

      console.log("‚öôÔ∏è Start OCCT conversie...");
      const params = {
        linearUnit: "millimeter",
        linearDeflectionType: "absolute_value",
        linearDeflection: 0.2,
        angularDeflection: 0.5
      };
      const result = occt.ReadStepFile(fileBuffer, params);

      if (!result || !result.success) {
        console.warn("‚ùå STEP import mislukt", result);
        $("viewerMeta").textContent = "STEP kon niet worden omgezet naar een mesh.";
        $("viewerPlaceholder").classList.remove("hidden");
        $("viewerPlaceholder").innerHTML =
          '<div class="badge error">Kon model niet renderen</div>' +
          '<div>Gebruik dit in de demo als scenario met een corrupt of onbekend CAD-bestand.</div>';
        $("viewerStatusDots").style.opacity = "0.15";
        return;
      }

      console.log("‚úÖ STEP succesvol geconverteerd, aantal meshes:", result.meshes?.length || 0);

      clearSceneMeshes();
      clearMeasurement();
      const scene = state.three.scene;

      (result.meshes || []).forEach((m, idx) => {
        console.log(`  üìê Mesh ${idx + 1}: ${m.attributes.position.array.length / 3} vertices`);

        const geom = new THREE.BufferGeometry();
        const posArr = new Float32Array(m.attributes.position.array);
        geom.setAttribute("position", new THREE.BufferAttribute(posArr, 3));

        if (m.attributes.normal && m.attributes.normal.array) {
          const normArr = new Float32Array(m.attributes.normal.array);
          geom.setAttribute("normal", new THREE.BufferAttribute(normArr, 3));
        } else {
          geom.computeVertexNormals();
        }

        const indexArr = new Uint32Array(m.index.array);
        geom.setIndex(new THREE.BufferAttribute(indexArr, 1));

        const material = new THREE.MeshStandardMaterial({
          color: colorArrayToHex(m.color),
          metalness: 0.15,
          roughness: 0.8
        });

        const mesh = new THREE.Mesh(geom, material);
        scene.add(mesh);
      });

      console.log("üé• Focus camera op model...");
      focusCameraOnScene();

      $("viewerTitle").textContent = state.stepFileName || "STEP-model";
      $("viewerMeta").textContent =
        "Model geladen. Muis: slepen = orbit, scroll = zoom, rechtsknop = pan. Meten: knop links.";
      $("viewerStatusDots").style.opacity = "0.15";
      $("viewerPlaceholder").classList.add("hidden");

      console.log("‚úÖ Model volledig geladen en zichtbaar!");
    } catch (err) {
      console.error("‚ùå Fout bij lezen STEP-bestand:", err);
      $("viewerMeta").textContent = "Er ging iets mis bij het lezen van het STEP-bestand.";
      $("viewerPlaceholder").classList.remove("hidden");
      $("viewerPlaceholder").innerHTML =
        '<div class="badge error">Viewer fout</div>' +
        '<div>Bekijk de browserconsole voor details.</div>';
      $("viewerStatusDots").style.opacity = "0.15";
    }
  }

  // ---- Events ----
  $("stepFileInput").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    state.stepFile = file;
    state.stepFileName = file.name;
    loadStepIntoViewer(file);
  });

  // Demo-knop: DEMOSTEPFILE.STEP uit dezelfde map
  $("btnLoadDemo").addEventListener("click", async () => {
    try {
      const response = await fetch("DEMOSTEPFILE.STEP");
      if (!response.ok) {
        alert("Kon DEMOSTEPFILE.STEP niet laden. Staat het bestand in dezelfde map als deze HTML?");
        return;
      }
      const blob = await response.blob();
      const demoFile = new File([blob], "DEMOSTEPFILE.STEP", { type: "application/octet-stream" });

      state.stepFile = demoFile;
      state.stepFileName = demoFile.name;

      loadStepIntoViewer(demoFile);
    } catch (err) {
      console.error("Demo load error:", err);
      alert("Fout bij laden demo-bestand. Zie console voor details.");
    }
  });

  // Refresh: nieuwe sessie starten
  $("btnRefresh").addEventListener("click", () => {
    location.reload();
  });

  // Meten-knop
  $("btnMeasureToggle").addEventListener("click", () => {
    state.measure.enabled = !state.measure.enabled;
    const btn = $("btnMeasureToggle");

    if (state.measure.enabled) {
      btn.textContent = "Meten: aan";
      btn.classList.add("primary");
      ensureMeasureLabel();
    } else {
      btn.textContent = "Meten: uit";
      btn.classList.remove("primary");
      clearMeasurement();
    }
  });
</script>
</body>
</html>
